// schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Guest {
  id          Int       @id @default(autoincrement())
  firstName   String
  lastName    String
  email       String    @unique
  phoneNumber String
  address     String?
  bookings    Booking[]
}

model Room {
  id              Int               @id @default(autoincrement())
  roomNumber      String            @unique
  type            RoomType          @default(SENCILLA)
  capacity        Int               @default(2)
  pricePerNight   Decimal           @db.Decimal(10, 2)
  description     String?
  amenities       String[]          @default([])
  isAvailable     Boolean           @default(true)
  bookingRooms    BookingRoom[] // Cambiado de bookings a bookingRooms
  roomInventory   RoomInventory?
  channelRates    ChannelRate[]
  status          RoomStatus        @default(LIBRE)
  floor           Int               @default(1) // Nuevo campo para piso
  BookingMovement BookingMovement[]
}

enum RoomType {
  SENCILLA
  SENCILLA_ESPECIAL
  DOBLE
  DOBLE_ESPECIAL
  SUITE_A
  SUITE_B
}

enum RoomStatus {
  LIBRE
  RESERVADA
  SUCIA
  BLOQUEADA
  OCUPADA
  EN_MANTENIMIENTO
  LIMPIEZA
}

model Booking {
  id              Int                   @id @default(autoincrement())
  guestId         Int
  checkInDate     DateTime              @db.Date
  checkOutDate    DateTime              @db.Date
  totalPrice      Decimal               @db.Decimal(10, 2)
  status          String
  guest           Guest                 @relation(fields: [guestId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  numberOfGuests  Int                   @default(1)
  bookingRooms    BookingRoom[]
  payments        Payment[]
  modifications   BookingModification[]
  BookingMovement BookingMovement[]
  BookingEvent    BookingEvent[]
}

model Payment {
  id            Int      @id @default(autoincrement())
  bookingId     Int
  amount        Decimal  @db.Decimal(10, 2)
  paymentDate   DateTime @db.Date
  paymentMethod String
  booking       Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

enum UserRole {
  ADMIN
  RECEPTIONIST
  HOUSEKEEPER
  SUPERADMIN
}

model User {
  id              Int                @id @default(autoincrement())
  username        String             @unique
  name            String
  lastName        String?
  passwordHash    String
  email           String             @unique
  role            UserRole           @default(RECEPTIONIST)
  departmentId    Int?
  position        String?
  hireDate        DateTime?          @db.Date
  status          EmployeeStatus     @default(ACTIVE)
  department      Department?        @relation(fields: [departmentId], references: [id])
  attendance      Attendance[]
  schedules       Schedule[]
  documents       EmployeeDocument[]
  BookingMovement BookingMovement[]
  BookingEvent    BookingEvent[]
}

enum EmployeeStatus {
  ACTIVE
  INACTIVE
  ON_LEAVE
  TERMINATED
  SUSPENDED
}

model Department {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?
  users       User[]
}

model Attendance {
  id           Int              @id @default(autoincrement())
  userId       Int
  checkInTime  DateTime
  checkOutTime DateTime?
  date         DateTime         @db.Date
  status       AttendanceStatus
  notes        String?
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  HALF_DAY
  ON_LEAVE
}

model Schedule {
  id          Int      @id @default(autoincrement())
  userId      Int
  startTime   DateTime
  endTime     DateTime
  dayOfWeek   Int // 0-6, Sunday-Saturday
  isRecurring Boolean  @default(true)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model EmployeeDocument {
  id           Int       @id @default(autoincrement())
  userId       Int
  documentType String
  documentName String
  documentUrl  String
  uploadDate   DateTime  @default(now())
  expiryDate   DateTime?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model RoomInventory {
  id                  Int       @id @default(autoincrement())
  roomId              Int       @unique
  maintenanceStatus   String
  lastMaintenanceDate DateTime? @db.Date
  room                Room      @relation(fields: [roomId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Amenity {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?
  isAvailable Boolean @default(true)
}

model Channel {
  id           Int           @id @default(autoincrement())
  channelName  String        @unique
  contactInfo  String?
  channelRates ChannelRate[]
}

model ChannelRate {
  id        Int      @id @default(autoincrement())
  roomId    Int
  channelId Int
  rate      Decimal  @db.Decimal(10, 2)
  startDate DateTime @db.Date
  endDate   DateTime @db.Date
  room      Room     @relation(fields: [roomId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  channel   Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model BookingSource {
  id         Int    @id @default(autoincrement())
  sourceName String @unique
}

model BookingModification {
  id                  Int      @id @default(autoincrement())
  bookingId           Int
  modificationDate    DateTime @db.Date
  modificationDetails String
  booking             Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

// Nuevo modelo para manejar la relación muchos a muchos entre Booking y Room
model BookingRoom {
  id          Int     @id @default(autoincrement())
  bookingId   Int
  roomId      Int
  priceAtTime Decimal @db.Decimal(10, 2)
  booking     Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  room        Room    @relation(fields: [roomId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([bookingId, roomId]) // Asegura que no haya duplicados
}

// --- Movimientos y eventos de reservas ---
model BookingMovement {
  id        Int          @id @default(autoincrement())
  bookingId Int
  roomId    Int? // Para asociar el movimiento a una habitación específica si aplica
  type      MovementType
  amount    Decimal?     @db.Decimal(10, 2)
  subtotal  Decimal?     @db.Decimal(10, 2) // Para reportes
  iva       Decimal?     @db.Decimal(10, 2) // IVA calculado
  tax3      Decimal?     @db.Decimal(10, 2) // Impuesto 3%
  total     Decimal?     @db.Decimal(10, 2) // Total con impuestos
  reference String? // Referencia o folio
  concept   String? // Descripción del concepto
  createdAt DateTime     @default(now())
  turnoId   Int? // Turno en el que se registró
  userId    Int? // Usuario que registró el movimiento
  booking   Booking      @relation(fields: [bookingId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  room      Room?        @relation(fields: [roomId], references: [id])
  turno     Turno?       @relation(fields: [turnoId], references: [id])
  user      User?        @relation(fields: [userId], references: [id])
}

enum MovementType {
  PAYMENT
  EXTENSION
  CANCELLATION
  EXTRA_CHARGE
  REFUND
  OTHER
}

model BookingEvent {
  id        Int              @id @default(autoincrement())
  bookingId Int
  eventType BookingEventType
  eventDate DateTime         @default(now())
  userId    Int?
  notes     String?
  booking   Booking          @relation(fields: [bookingId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user      User?            @relation(fields: [userId], references: [id])
}

enum BookingEventType {
  CHECKIN
  CHECKOUT
  EXTENSION
  NO_SHOW
  EARLY_CHECKOUT
  OTHER
}

// --- Turnos para reporte de conceptos ---
model Turno {
  id          Int               @id @default(autoincrement())
  numero      Int // 1, 2, 3
  nombre      String // Ej: "Turno Matutino"
  inicio      DateTime // Hora de inicio del turno
  fin         DateTime // Hora de fin del turno
  movimientos BookingMovement[]
}
